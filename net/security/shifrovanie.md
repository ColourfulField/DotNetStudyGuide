В это разделе мы рассмотрим шифрование информации и защиту данных пользователей.

Для начала разберём 2 важных понятия:

**Шифрование** - процесс обфускации текста в нечитаемую строку при помощи специального "ключа". Результирующую строку можно вернуть в исходное состояние при помощи этого же или другого ключа \(зависит от алгоритма шифрования\). Ключ - это строка определённой длины, состоящая из случайных символов.

**Хеширование **-** **процесс обфускации текста в нечитаемую строку при помощи хеш-функции. Результирующую строку \(хеш\) невозможно вернуть в исходное состояние. При передаче в хеш-функцию одной и той же строки хеш тоже будет одним и тем же.

Ключевая разница между этими понятиями в том, что хеш вернуть в исходное состояние невозможно, а зашифрованный текст - возможно. Также стоит заметить, что зашифрованная строка обычно имеет бОльшую длину, чем оригинальная, а хеш - меньшую \(длина хеша фиксирована и не зависит от длины оригинальной строки\).

**Шифрование **бывает двух типов - симметричное и асимметричное.

Общий подход асимметричного шифрования выглядит следующим образом:

![](/assets/import.png)

* Сторона А создаёт два ключа - публичный и приватный \(открытый и закрытый\). 
* Открытый ключ свободно передается стороне Б по незищещенному каналу
* Сторона Б шифрует данные при помощи публичного ключа и передаёт зашифрованные данные стороне А
* Сторона А расшифровывает данные своим приватным ключом \(только этот ключ может использоваться для расшифровки данных\)

Симметричное шифрование использует один и тот же ключ для шифрования и дешифрования.

Асимметричное шифрование имеет один большой минус: размер ключа очень большой и напрямую зависит от размера шифруемого сообщения \(например, RSA-ключ длиной в 256 байт может зашифровать сообщение длиной не больше 245 байт\). Симметричное шифрование лишено этого минуса.

Поэтому, чтобы сделать соединение безопасным, а передачу зашифрованных данных любой длины возможным, две стороны сначала обмениваются асимметричными ключами. После этого по защищенному каналу передаётся симметричный ключ и всё остальное общение осуществляется при помощи симметричного шифрования.

**Хранение паролей в базе данных**

Есть множество вариантов хранения паролей в БД, начиная с открытого вида \(plain text\) до шифрования и хеширования с использованием "соли". Самый распространенный вариант - хеширование при помощи "соли". Работает он следующим образом:

Для сохранения пароля в БД \(при регистрации пользователя\):

* Пароль передаётся на сервер через зашифрованное соединение \(HTTPS\)
* Сервер генерирует "соль" - случайную строку, которая конкатенируется \(добавляется\) к паролю пользователя
* Сервер строит хеш строки, полученной в предыдущем пункте
* Хеш и "соль" сохраняются в БД как 2 отдельных поля.

Для проверки действительности пароля:

* Пароль передаётся на сервер через зашифрованное соединение \(HTTPS\)
* Сервер считывает из БД "соль" и конкатенирует \(добавляет\) её к паролю пользователя
* Сервер строит хеш строки, полученной в предыдущем пункте
* Сервер сверяет только что построенный хеш с тем, который хранится в базе. При совпадении хешей, пароль считается подлинным

Такой подход позволяет нам **никогда **не иметь в БД пароль пользователя в том виде, в котором он может быть прочитан. В случае взлома БД пароли пользователей не будут украдены.

Заметка: использование соли необходимо, чтобы бороться с атакой при помощи "радужных таблиц". Дело в том, что к популярным паролям можно рассчитать хеш для всех распространенных функций шифрования. Имея под рукой такую таблицу хешей, можно сравнивать её с хешами паролей из украденной базы и узнавать пароли хотя бы к части аккаунтов в системе. Добавление "соли" к каждому паролю решает эту проблему, т.к. пароль с "солью" и пароль без "соли" имеют разные хеши.

**HTTPS**

HTTPS - это соединение, которое использует шифрование для передачи всех данных пользователя между браузером и сервером. Без использования HTTPS любой человек, находящийся в той же сети, что и оригинальный пользователь, имеет возможность перехватить и украсть данные. Более того, любой человек, имеющий доступ к участку сети между клиентом и сервером, тоже может перехватить данные \(например, это может делать интернет-провайдер\). Всегда используйте HTTPS для production-серверов, даже если вы не передаёте чувствительных данных вроде паролей или номеров кредитных карт.

Также не передавайте чувствительные данные в URL запроса \(как параметры HTTP-запроса или как часть URL\). Дело в том, что URL запроса будет сохранен в истории браузера в незашифрованном виде, что небезопасно для пользователя в долгосрочной перспективе.

