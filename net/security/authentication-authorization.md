В чём же разница между Авторизацией и Аутентификацией?

**Аутентификация **\(**Authentication**\) - это определение того, **кем **себя выдаёт пользователь. Например, залогинившись в сайт при помощи логина "Vasya123", наш сервер будет знать, что работает с пользователем "Вася Пупкин".

**Авторизация **\(**Authorization**\) - это определение того, есть ли у пользователя **права **на доступ к определённому ресурсу. Например, сервер может свободно отдавать доступ к главной странице сайта всем пользователям, но доступ к личным файлам пользователя "Вася Пупкин" имеет только сам Вася Пупкин.

Доступ к ресурсам может рассматриваться в любых комбинациях аутентификации и авторизации пользователя.

Пользователь может быть:

* Аутентифицирован и Авторизован - авторизованный пользователь "Вася Пупкин" может просматривать ресурс "личные файлы Васи Пупкина"
* Аутентифицирован и не Авторизован - авторизованный пользователь "Вася Пупкин" не может просматривать ресурс "личные файлы Ивана Петрова"
* Не Аутентифицирован и Авторизован - анонимные \(не авторизованные\) пользователи могут свободно просматривать ресурс "главная страница сайта"
* Не Аутентифицирован и не Авторизован - анонимные пользователи не могут просматривать ресурс "личные файлы Васи Пупкина".

Как видим, хоть наличие прав у пользователя на доступ к ресурсу и может зависеть от того, вошел ли пользователь в систему, процессы аутентификации и авторизации всё же являются независимыми друг от друга.

Как же в итоге подойти к проведению авторизации и аутентификации? Для начала давайте рассмотрим ещё один термин:

**Идентификация **\(**Identification**\) -  присвоение пользователю идентификатора и / или сравнение идентификатора с перечнем присвоенных идентификаторов.

Мало единожды проверить совпадает ли пароль и логин пользователя с теми, которые сохранены в БД -  нужно как-то дать ему возможность пользоваться сайтом дальше, не требуя логин и пароль при доступе к любому защищенному ресурсу. Для этого после проверки пользователю выдаётся идентификатор\(токен\), который он должен отправлять на сервер с каждым запросом, чтобы подтверждать свою личность.

Есть множество методов того, как управлять этим идентификатором, и какую именно информацию в него "зашивать".

Сначала нужно определить что важнее вашему приложению - быстродействие или безопасность, поскольку в токене можно сохранять не только информацию о личности пользователя, но и информацию о списке его прав. Рассмотрим подробнее:

* Токен, в котором содержится только информация о личности пользователя имеет преимущество в безопасности - в случае изменения прав/доступов пользователя, он ни в коем случае не сможет получить доступ к ресурсу, который у него "отняли". Этот подход имеет и минус - с каждым запросом необходимо получать из БД список прав пользователя, что негативно влияет на быстродействие. Для повышения быстродействия списки прав пользователей иногда кешируют, но такой подход заставляет очень внимаьельно следить за тем, чтобы в кеше не содержались только актуальные данные.
* Токен, в котором зашивается информация о правах пользователя, позволяет избежать шага  получения списка прав из БД, но имеет большой недостаток - поскольку токен хранится на стороне пользователя, сервер не может удалить токен после изменения прав пользователя. Это означает, что даже если пользователь был полностью удалён из системы, он всё ещё сможет получать доступ к ресурсам системы до тех пор, пока не истечёт токен.

Рассмотрим также и варианты определения времени жизни токена:

* Выдача одного access-токена с астономически огромным сроком жизни \(год\) - самый небезопасный вариант. Никогда не используйте этот вариант в реальных приложениях
* Выдача одного access-токена на небольшой срок \(неделя\) - Этот вариант ничем принципиально не отличается от предыдущего, и его тоже стоит избегать по возможности, но такой вариант можно исплементировать в качестве очень раннего прототипа, если авторизация не является вашим приоритетом в начале разработки
* Выдача одного "скользящего" access-токена на малый срок. Этот метод характерен тем, что токен выдаётся на небольшой срок \(5-30 минут\), но с каждым запросом он обновляется. Это позволяет пользователю свободно пользоваться сайтом в течении длительного времени, но в случе длительного простоя, пользователь вынужден авторизироваться заново. Этот метод полезен для вебсайтов с критическим содержимым - например, для интернет-банкинга, но является одним из самых низких по производительности из-за необходимости постоянно генерировать новые токены.
* Выдача двух токенов - access-токена на короткий срок\(30-60 минут\), а также refresh-tokena на длительный срок\(неделя\). При этом, refresh-token содержит особый идентификатор, который сохраняется в БД сервера. Механика работы такова: пользователь использует access-токен в течении заданного режима времени. Как только его срок жизни кончается, сервер возвращает ошибку авторизации, и клиент пытается обновить access-токен, используя refresh-token. Для этого на особый метод контроллера отправляется запрос, содержащий refresh-token. Сервер сверяет содержимое refresh-token с тем, что лежит в базе, и при успешном совпадении возвращает новый access token, с актуальным набором прав. При выборе срока жизни refresh-token'а можно пользоваться методами, описанными выше \(например, при каждом обновлении access-token'a можно обновлять и refresh-token\). Данный метод позволяет комбинировать быстродействие от зашивания информации о правах пользователя в токен, и повышенной безопасности от того, что пользователь имеет неправильные права не больше 30-60 минут.



