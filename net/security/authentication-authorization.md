В чём же разница между Авторизацией и Аутентификацией?

**Аутентификация **\(**Authentication**\) - это определение того, **кем **себя выдаёт пользователь. Например, человек залогинился в сайт под логином "Vasya123". При этом наш сервер будет знать, что работает с пользователем "Вася Пупкин".

**Авторизация **\(**Authorization**\) - это определение того, есть ли у пользователя **права **на доступ к определённому ресурсу. Например, сервер может свободно отдавать доступ к главной странице сайта всем пользователям, но доступ к личным файлам пользователя "Вася Пупкин" имеет только сам Вася Пупкин.

Доступ к ресурсам может рассматриваться в любых комбинациях аутентификации и авторизации пользователя.

Пользователь может быть:

* Аутентифицирован и Авторизован - авторизованный пользователь "Вася Пупкин" может просматривать ресурс "личные файлы Васи Пупкина"
* Аутентифицирован и не Авторизован - авторизованный пользователь "Вася Пупкин" не может просматривать ресурс "личные файлы Ивана Петрова"
* Не Аутентифицирован и Авторизован - анонимные \(неавторизованные\) пользователи могут свободно просматривать ресурс "главная страница сайта"
* Не Аутентифицирован и не Авторизован - анонимные пользователи не могут просматривать ресурс "личные файлы Васи Пупкина".

Как видим, хоть наличие прав у пользователя на доступ к ресурсу и может зависеть от того, вошел ли пользователь в систему, процессы аутентификации и авторизации всё же являются независимыми друг от друга.

Как же в итоге подойти к проведению авторизации и аутентификации? Для начала давайте рассмотрим ещё один термин:

**Идентификация **\(**Identification**\) -  присвоение пользователю идентификатора и / или сравнение идентификатора с перечнем присвоенных идентификаторов.

Мало единожды проверить, совпадает ли пароль и логин пользователя с теми, которые сохранены в БД. Нужно как-то дать ему возможность пользоваться сайтом дальше, не требуя логин и пароль при доступе к любому защищенному ресурсу. Для этого пользователю после проверки выдаётся идентификатор \(токен\), который он должен отправлять на сервер с каждым запросом, чтобы подтверждать свою личность.

Есть много способов управлять этим идентификатором и информацией, которую можно в него "зашивать".

Сначала нужно определить, что важнее вашему приложению: быстродействие или безопасность. Поскольку в токене можно сохранять не только информацию о личности пользователя, но и о списке его прав. Рассмотрим подробнее:

* Токен, в котором содержится только информация о личности пользователя, имеет преимущество в безопасности. В случае изменения прав/доступов пользователя, он ни в коем случае не сможет получить доступ к ресурсу, который у него "отняли". Этот подход имеет и минус: с каждым запросом необходимо получать из БД список прав пользователя, что негативно влияет на быстродействие. Для повышения быстродействия списки прав пользователей иногда кэшируют. Но такой подход заставляет очень внимательно следить за тем, чтобы в кэше не содержались только актуальные данные.
* Токен, в котором зашивается информация о правах пользователя, позволяет избежать шага получения списка прав из БД, но имеет большой недостаток: поскольку токен хранится на стороне пользователя, сервер не может удалить его после изменения прав пользователя. Это означает, что, даже если пользователь был полностью удалён из системы, он сможет получать доступ к её ресурсам до тех пор, пока не истечёт токен.

Рассмотрим варианты определения времени жизни токена:

* Выдача одного access-токена с огромным сроком жизни \(год\) - самый небезопасный вариант. Никогда не используйте этот вариант в реальных приложениях
* Выдача одного access-токена на небольшой срок \(неделя\) - этот вариант принципиально не отличается от предыдущего. Его тоже стоит избегать, но он может быть имплементирован в качестве очень раннего прототипа, если авторизация не является вашим приоритетом в начале разработки
* Выдача одного "скользящего" access-токена на малый срок. При этом варианте токен выдаётся на небольшой срок \(5-30 минут\), но с каждым запросом он обновляется. Это позволяет пользователю свободно юзать сайт в течение долгого времени. Но в случае длительного простоя пользователь вынужден авторизироваться заново. Этот метод полезен для веб-сайтов с критическим содержимым \(например, для интернет-банкинга\), но является одним из самых низких по производительности из-за необходимости постоянно генерировать новые токены.
* Выдача двух токенов: access-токена на короткий срок\(30-60 минут\) и refresh-tokena на длительный \(неделя\). При этом refresh-token содержит особый идентификатор, который сохраняется в БД сервера. Механика работы такова: пользователь использует access-токен в течение заданного режима времени, как только срок его жизни кончается, сервер возвращает ошибку авторизации, а клиент пытается обновить access-токен, используя refresh-token. Для этого на особый метод контроллера отправляется запрос, содержащий refresh-token. Сервер сверяет содержимое refresh-token'а с тем, что лежит в базе. При совпадении сервер возвращает новый access-token с актуальным набором прав. При выборе срока жизни refresh-token'а можно пользоваться методами, описанными выше \(например, при каждом обновлении access-token'a можно обновлять и refresh-token\). Данный метод позволяет комбинировать быстродействие \(от зашивания информации о правах пользователя в токен\) и повышенную безопасность \(так как пользователь имеет неправильные права не больше 30-60 минут\).



